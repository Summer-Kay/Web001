package com.scb.mxg.mls.rt.gfi.processor;
import com.scb.mxg.mls.rt.gfi.lookup.StaticDataDict;
import com.scb.mxg.mls.rt.gfi.utils.RegressionAssist;
import com.scb.mxg.mls.rt.gfi.utils.RegressionAssist.RegressionResult;
import com.scb.mxg.mls.rt.gfi.utils.XPathParser;
import com.scb.mxg.mls.rt.gfi.utils.XmlUtils;
import org.apache.camel.Exchange;
import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.io.FileUtils;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.xmlunit.builder.DiffBuilder;
import org.xmlunit.builder.Input;
import org.xmlunit.diff.Diff;
import org.xmlunit.diff.Difference;
import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
public final class RegressionTestProcessor extends BaseProcessor {
    private final static Logger LOG = LoggerFactory
            .getLogger(RegressionTestProcessor.class);
    private File expectedMxmlFolder;
    private File outputMxmlFolder;
    private List<String> ignoreXpathList = new ArrayList<String>();
    private File uvtInputFolder;
    public RegressionTestProcessor() {
        outputMxmlFolder = new File(System.getProperty("root_dir")
                + File.separator + "regression_output");
        if (!outputMxmlFolder.exists()) {
            outputMxmlFolder.mkdirs();
        }
        LOG.info("regression output mxml folder: {}",
                outputMxmlFolder.getAbsolutePath());
        expectedMxmlFolder = new File(System.getProperty("root_dir")
                + File.separator + "regression_expected");
        if (!expectedMxmlFolder.exists()) {
            expectedMxmlFolder.mkdirs();
        }
        LOG.info("regression expected mxml folder: {}",
                expectedMxmlFolder.getAbsolutePath());
        File xpathIgnoreConfigFile = new File(System.getProperty("root_dir")
                + File.separator + "xpath_ignore.config");
        LOG.info("xpath ignoring configuration file: {}",
                xpathIgnoreConfigFile.getAbsolutePath());
        if (xpathIgnoreConfigFile.exists()) {
            try {
                ignoreXpathList = FileUtils.readLines(xpathIgnoreConfigFile,
                        "UTF-8");
                LOG.info("below xpath will be ignored in mxml comparison");
                LOG.info(ignoreXpathList.toString());
            } catch (IOException e) {
                LOG.info("load xpath ignoring config", e);
            }
        } else {
            LOG.info("xpath ignoreing configuration file is not existing.");
        }
    }
    @Override
    
    public void handleExchange(Exchange exchange) throws Exception {
        Path rootDir = Paths.get(System.getProperty("root_dir"));
        Path uvtInputFolderPath = rootDir.resolve("regression_input").normalize();
        if (!uvtInputFolderPath.toAbsolutePath().startsWith(rootDir.toAbsolutePath())) {
            throw new SecurityException("Invalid root_dir path");
        }
        Files.createDirectories(uvtInputFolderPath);
        Path filePath = uvtInputFolderPath.resolve("generate_report.flag").normalize();
        if (!filePath.toAbsolutePath().startsWith(uvtInputFolderPath.toAbsolutePath())) {
            throw new SecurityException("Invalid file path detected");
        }
        File file = filePath.toFile();
        if(!file.exists()) {
            try {
                file.createNewFile();
            } catch (IOException e) {
                LOG.error("Exception when RegressionTestProcessor handleExchange!", e);            }
        }
        String singleLegFixML = StringUtils.trimToEmpty(exchange.getIn().getBody(
                String.class));
        XPathParser intraXmlParser = new XPathParser(singleLegFixML);
        String legType = intraXmlParser.evaluate(CONFIG.getString("gfi.xpath.LegType"));
        String tradeExternalId = intraXmlParser.evaluate(CONFIG.getString("gfi.xpath.tradeExternalId"));
        String maxLegVal = intraXmlParser.evaluate(CONFIG.getString("gfi.xpath.MaxLegVal"));
        String legID =intraXmlParser.evaluate(CONFIG.getString("gfi.xpath.LegID"));
        String legSubID=intraXmlParser.evaluate(CONFIG.getString("gfi.xpath.LegSubID"));
        String externalId = getFullTradeId(tradeExternalId,legType,maxLegVal,legID,legSubID);
        LOG.info(externalId);
        // transform
        transformStages(exchange, singleLegFixML);
        Set<String> errors = StaticDataDict.getErrorList();
        if (CollectionUtils.isNotEmpty(errors)) {
            RegressionAssist.addRegressionResult(new RegressionResult(
                    externalId, "failed", errors.toString()));
        } else {
            // compare
            String mxml = exchange.getIn().getBody(String.class);
            Path outputBase = outputMxmlFolder.toPath();
            Path outputMxmlPath = outputBase.resolve(externalId + ".xml").normalize();
            if (!outputMxmlPath.toAbsolutePath().startsWith(outputBase.toAbsolutePath())) {
                throw new SecurityException("Invalid output MXML path: " + externalId);
            }
            Files.write(outputMxmlPath, mxml.getBytes(StandardCharsets.UTF_8));
            Path expectedBase = expectedMxmlFolder.toPath();
            Path expectedMxmlPath = expectedBase.resolve(externalId + ".xml").normalize();
            if (!expectedMxmlPath.toAbsolutePath().startsWith(expectedBase.toAbsolutePath())) {
                throw new SecurityException("Invalid expected MXML path: " + externalId);
            }
            File expectedMxml = expectedMxmlPath.toFile();
            if (expectedMxml.exists()) {
                String expectedMxmlStr = FileUtils.readFileToString(
                        expectedMxml, "UTF-8");
                XPathParser mxmlParser = new XPathParser(mxml);
                XPathParser expectedParser = new XPathParser(expectedMxmlStr);
                for (String xpath : ignoreXpathList) {
                    if (StringUtils.isBlank(xpath)) {
                        continue;
                    }
                    mxmlParser.removeNode(StringUtils.trim(xpath));
                    expectedParser.removeNode(StringUtils.trim(xpath));
                }
                Diff diff = DiffBuilder
                        .compare(
                                Input.fromString(StringUtils.trim(XmlUtils
                                        .formatXml(expectedMxmlStr))))
                        .withTest(
                                Input.fromString(StringUtils.trim(XmlUtils
                                        .formatXml(mxml))))
                        .build();
                if (diff.hasDifferences()) {
                    Iterator<Difference> differences = diff.getDifferences()
                            .iterator();
                    Difference difference = null;
                    List<String> differenceList = new ArrayList<>();
                    while (differences.hasNext()) {
                        difference = differences.next();
                        differenceList.add(difference.toString());
                    }
                    RegressionAssist.addRegressionResult(new RegressionResult(
                            externalId, "diff", StringUtils.join(
                            differenceList.toArray(), "\n")));
                } else {
                    RegressionAssist.addRegressionResult(new RegressionResult(
                            externalId, "match", ""));
                }
            } else {
                RegressionAssist.addRegressionResult(new RegressionResult(
                        externalId, "failed", "excepted file is not existing: "
                        + expectedMxml.getAbsolutePath()));
            }
        }
    }
}
