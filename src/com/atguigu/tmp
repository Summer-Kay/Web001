package com.scb.mxg.mls.rt.gfi.processor;

import com.scb.mxg.mls.rt.data.CommonStaticData;
import com.scb.mxg.mls.rt.utils.BeanUtils;
import com.scb.mxg.mls.rt.gfi.vo.TradeEvent;
import com.scb.mxg.mls.trade.TradeEventType;
import com.scb.mxg.mls.vo.Journal;
import com.scb.mxg.mls.utils.XPathParser;
import net.sf.saxon.s9api.XsltTransformer;
import org.apache.camel.Exchange;
import org.apache.commons.io.IOUtils;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Answers;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.powermock.api.mockito.PowerMockito;
import org.powermock.core.classloader.annotations.PowerMockIgnore;
import org.powermock.core.classloader.annotations.PrepareForTest;
import org.powermock.modules.junit4.PowerMockRunner;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.ResultSetExtractor;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.jdbc.core.namedparam.SqlParameterSource;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.support.TransactionTemplate;

import java.util.*;

import static org.junit.Assert.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

@RunWith(PowerMockRunner.class)
@PrepareForTest({BeanUtils.class, CommonStaticData.class, XPathParser.class, DateFormatUtils.class, DateUtils.class, StpProcessor.class})
@PowerMockIgnore({"javax.management.*", "javax.script.*", "javax.xml.*", "org.xml.*", "org.w3c.*"})
public class StpProcessorTest {

    private StpProcessor stpProcessor;
    private TransactionTemplate mlsDbTransactionTemplate;
    private String fixmessage;
    private String fixmessage2;
    private String fixmessage3;
    private String fixmessage4;
    private String errorFixMessage;
    
    @Mock
    private CommonStaticData commonStaticData;
    
    @Mock
    private JdbcTemplate mlsDbJdbcTemplate;
    
    @Mock
    private NamedParameterJdbcTemplate namedParameterJdbcTemplate;
    
    @Mock
    private PlatformTransactionManager transactionManager;
    
    @Mock
    private XsltTransformer xsltTransformer;
    
    @Mock(answer = Answers.RETURNS_DEEP_STUBS)
    private Exchange exchange;
    
    @Mock(answer = Answers.RETURNS_DEEP_STUBS)
    private Exchange errorExchange;
    
    @Mock
    private XPathParser xPathParser;
    
    @Before
    public void setUp() throws Exception {
        fixmessage = IOUtils.toString(getClass().getResourceAsStream("/inputFiles/normalFixml.xml"), "UTF-8");
        fixmessage2 = IOUtils.toString(getClass().getResourceAsStream("/inputFiles/normalFixml2.xml"), "UTF-8");
        fixmessage3 = IOUtils.toString(getClass().getResourceAsStream("/inputFiles/normalFixml3.xml"), "UTF-8");
        fixmessage4 = IOUtils.toString(getClass().getResourceAsStream("/inputFiles/normalFixml4.xml"), "UTF-8");
        errorFixMessage = IOUtils.toString(getClass().getResourceAsStream("/inputFiles/errorFix.xml"), "UTF-8");
        
        stpProcessor = new StpProcessor();
        stpProcessor.setMlsDbJdbcTemplate(mlsDbJdbcTemplate);
        
        // Mock NamedParameterJdbcTemplate constructor
        PowerMockito.whenNew(NamedParameterJdbcTemplate.class)
            .withArguments(any(JdbcTemplate.class))
            .thenReturn(namedParameterJdbcTemplate);
        
        mlsDbTransactionTemplate = new TransactionTemplate(transactionManager);
        stpProcessor.setMlsDbTransactionTemplate(mlsDbTransactionTemplate);
        
        PowerMockito.mockStatic(BeanUtils.class);
        PowerMockito.when(BeanUtils.getBean("commonStaticData")).thenReturn(commonStaticData);
        
        // Mock XPathParser constructor
        PowerMockito.whenNew(XPathParser.class)
            .withArguments(anyString())
            .thenReturn(xPathParser);
        
        // Mock DateUtils and DateFormatUtils
        PowerMockito.mockStatic(DateUtils.class);
        PowerMockito.mockStatic(DateFormatUtils.class);
    }

    @Test
    public void testHandleExchange_NewTrade() throws Exception {
        // Arrange
        when(commonStaticData.lookupStaicData(anyString(), anyString(), anyInt())).thenReturn("");
        
        when(exchange.getIn().getBody(eq(String.class))).thenReturn(fixmessage);
        when(exchange.getProperty(eq("originalTrackingId"), eq(String.class))).thenReturn("test-tracking-id");
        
        // Mock XPathParser evaluations
        when(xPathParser.evaluate(anyString())).thenAnswer(invocation -> {
            String arg = invocation.getArgument(0);
            if (arg.contains("LegType")) return "HedgeLegs";
            if (arg.contains("LegSubID")) return "2";
            if (arg.contains("hedgeCurrency")) return "USD";
            if (arg.contains("tradeExternalId")) return "TRADE123";
            if (arg.contains("MaxLegVal")) return "1";
            if (arg.contains("LegID")) return "L1";
            if (arg.contains("tradeType")) return "FX";
            if (arg.contains("tradeDate")) return "20230101";
            if (arg.contains("trader")) return "TRADER01";
            return "";
        });
        
        // Mock isExisting to return false (new trade)
        when(namedParameterJdbcTemplate.queryForObject(
            anyString(), 
            any(Map.class), 
            eq(Long.class))
        ).thenReturn(0L);
        
        // Act
        stpProcessor.handleExchange(exchange);
        
        // Assert
        verify(exchange).setProperty(eq("_originalId"), anyString());
        verify(exchange).setProperty(eq("_originalSys"), anyString());
        verify(exchange).setProperty(eq("_version"), anyString());
        verify(exchange).setProperty(eq("_inJournalId"), any());
        verify(exchange).setProperty(eq("_trader"), eq("TRADER01"));
        verify(exchange).setProperty(eq("_tradeEvent"), eq(TradeEventType.NEW));
        
        // Verify saveJournal was called
        verify(exchange).getContext();
    }

    @Test
    public void testHandleExchange_ExistingTrade() throws Exception {
        // Arrange
        when(commonStaticData.lookupStaicData(anyString(), anyString(), anyInt())).thenReturn("");
        
        when(exchange.getIn().getBody(eq(String.class))).thenReturn(fixmessage);
        when(exchange.getProperty(eq("originalTrackingId"), eq(String.class))).thenReturn("test-tracking-id");
        
        // Mock XPathParser evaluations
        when(xPathParser.evaluate(anyString())).thenAnswer(invocation -> {
            String arg = invocation.getArgument(0);
            if (arg.contains("LegType")) return "HedgeLegs";
            if (arg.contains("LegSubID")) return "2";
            if (arg.contains("hedgeCurrency")) return "USD";
            if (arg.contains("tradeExternalId")) return "TRADE123";
            if (arg.contains("MaxLegVal")) return "1";
            if (arg.contains("LegID")) return "L1";
            if (arg.contains("tradeType")) return "FX";
            if (arg.contains("tradeDate")) return "20230101";
            if (arg.contains("trader")) return "TRADER01";
            return "";
        });
        
        // Mock isExisting to return true (existing trade)
        when(namedParameterJdbcTemplate.queryForObject(
            anyString(), 
            any(Map.class), 
            eq(Long.class))
        ).thenReturn(1L);
        
        // Mock DateUtils and DateFormatUtils
        when(DateUtils.parseDate(anyString(), anyString())).thenReturn(new Date());
        when(DateFormatUtils.format(any(Date.class), anyString())).thenReturn("2023-01-01");
        
        // Act
        stpProcessor.handleExchange(exchange);
        
        // Assert
        verify(exchange).setProperty(eq("_originalId"), anyString());
        verify(exchange).setProperty(eq("_originalSys"), anyString());
        verify(exchange).setProperty(eq("_version"), anyString());
        verify(exchange).setProperty(eq("_tradeEvent"), eq(TradeEventType.NEW));
        
        // Verify recordTradeEvent was called with DUPLICATE sub-action
        // This would require mocking the recordTradeEvent method
    }

    @Test
    public void testHandleExchange_InvalidHedgeLeg_ShouldIgnore() throws Exception {
        // Arrange
        when(commonStaticData.lookupStaicData(anyString(), anyString(), anyInt())).thenReturn("");
        
        when(exchange.getIn().getBody(eq(String.class))).thenReturn(fixmessage);
        
        // Mock XPathParser evaluations for invalid hedge leg
        when(xPathParser.evaluate(anyString())).thenAnswer(invocation -> {
            String arg = invocation.getArgument(0);
            if (arg.contains("LegType")) return "HedgeLegs";
            if (arg.contains("LegSubID")) return "2";
            if (arg.contains("hedgeCurrency")) return ""; // Empty currency
            return "";
        });
        
        // Act
        stpProcessor.handleExchange(exchange);
        
        // Assert - Should not process further when invalid hedge leg
        verify(exchange, never()).setProperty(eq("_originalId"), anyString());
        verify(exchange, never()).setProperty(eq("_originalSys"), anyString());
    }

    @Test
    public void testHandleExchange_NonHedgeLeg_ShouldProcess() throws Exception {
        // Arrange
        when(commonStaticData.lookupStaicData(anyString(), anyString(), anyInt())).thenReturn("");
        
        when(exchange.getIn().getBody(eq(String.class))).thenReturn(fixmessage);
        when(exchange.getProperty(eq("originalTrackingId"), eq(String.class))).thenReturn("test-tracking-id");
        
        // Mock XPathParser evaluations for non-hedge leg
        when(xPathParser.evaluate(anyString())).thenAnswer(invocation -> {
            String arg = invocation.getArgument(0);
            if (arg.contains("LegType")) return "OtherLegType";
            if (arg.contains("LegSubID")) return "1"; // Not 2
            if (arg.contains("tradeExternalId")) return "TRADE123";
            if (arg.contains("MaxLegVal")) return "1";
            if (arg.contains("LegID")) return "L1";
            if (arg.contains("tradeType")) return "FX";
            if (arg.contains("tradeDate")) return "20230101";
            if (arg.contains("trader")) return "TRADER01";
            return "";
        });
        
        when(namedParameterJdbcTemplate.queryForObject(
            anyString(), 
            any(Map.class), 
            eq(Long.class))
        ).thenReturn(0L);
        
        // Act
        stpProcessor.handleExchange(exchange);
        
        // Assert - Should process even if not hedge leg
        verify(exchange).setProperty(eq("_originalId"), anyString());
        verify(exchange).setProperty(eq("_originalSys"), anyString());
    }

    @Test
    public void testIsExisting_ReturnsTrue() {
        // Arrange
        when(namedParameterJdbcTemplate.queryForObject(
            anyString(), 
            any(Map.class), 
            eq(Long.class))
        ).thenReturn(1L);
        
        // Act
        boolean result = stpProcessor.isExisting("TEST123", "GFI");
        
        // Assert
        assertTrue(result);
        verify(namedParameterJdbcTemplate).queryForObject(
            anyString(), 
            any(Map.class), 
            eq(Long.class)
        );
    }

    @Test
    public void testIsExisting_ReturnsFalse() {
        // Arrange
        when(namedParameterJdbcTemplate.queryForObject(
            anyString(), 
            any(Map.class), 
            eq(Long.class))
        ).thenReturn(0L);
        
        // Act
        boolean result = stpProcessor.isExisting("TEST123", "GFI");
        
        // Assert
        assertFalse(result);
    }

    @Test
    public void testIsExisting_ExceptionHandling() {
        // Arrange
        when(namedParameterJdbcTemplate.queryForObject(
            anyString(), 
            any(Map.class), 
            eq(Long.class))
        ).thenThrow(new RuntimeException("DB Error"));
        
        // Act
        boolean result = stpProcessor.isExisting("TEST123", "GFI");
        
        // Assert - Should return false on exception
        assertFalse(result);
    }

    @Test
    public void testHandleExchange_ExceptionInProcessing() throws Exception {
        // Arrange
        when(commonStaticData.lookupStaicData(anyString(), anyString(), anyInt())).thenThrow(new RuntimeException("Config error"));
        
        when(exchange.getIn().getBody(eq(String.class))).thenReturn(fixmessage);
        
        // Act & Assert
        try {
            stpProcessor.handleExchange(exchange);
            fail("Should have thrown exception");
        } catch (Exception e) {
            // Expected
        }
    }

    @Test
    public void testGetFullTradeId() throws Exception {
        // Use reflection to test private method
        java.lang.reflect.Method method = StpProcessor.class.getDeclaredMethod(
            "getFullTradeId", 
            String.class, String.class, String.class, String.class, String.class
        );
        method.setAccessible(true);
        
        // Act
        String result = (String) method.invoke(
            stpProcessor, 
            "TRADE123", "HedgeLegs", "1", "L1", "2"
        );
        
        // Assert
        assertNotNull(result);
        assertTrue(result.contains("TRADE123"));
    }

    @Test
    public void testHandleExchange_MultipleScenarios() throws Exception {
        // Test with different XML messages
        testWithFixMessage(fixmessage, "normalFixml.xml");
        testWithFixMessage(fixmessage2, "normalFixml2.xml");
        testWithFixMessage(fixmessage3, "normalFixml3.xml");
        testWithFixMessage(fixmessage4, "normalFixml4.xml");
    }

    private void testWithFixMessage(String fixMessage, String fileName) throws Exception {
        // Reset mocks
        reset(exchange, xPathParser, namedParameterJdbcTemplate);
        
        // Setup for this specific message
        when(exchange.getIn().getBody(eq(String.class))).thenReturn(fixMessage);
        when(exchange.getProperty(eq("originalTrackingId"), eq(String.class))).thenReturn("tracking-" + fileName);
        
        // Generic XPath responses
        when(xPathParser.evaluate(anyString())).thenAnswer(invocation -> {
            String arg = invocation.getArgument(0);
            if (arg.contains("LegSubID")) return "1"; // Default to valid
            if (arg.contains("tradeExternalId")) return "TRADE-" + fileName;
            return "TEST_VALUE";
        });
        
        when(namedParameterJdbcTemplate.queryForObject(
            anyString(), 
            any(Map.class), 
            eq(Long.class))
        ).thenReturn(0L);
        
        // Act
        stpProcessor.handleExchange(exchange);
        
        // Verify basic properties were set
        verify(exchange, atLeastOnce()).setProperty(eq("_originalId"), anyString());
        verify(exchange, atLeastOnce()).setProperty(eq("_originalSys"), anyString());
    }

    @Test
    public void testHandleExchange_WithMockedConfig() throws Exception {
        // Arrange - Mock the CONFIG
        PowerMockito.mockStatic(BaseProcessor.class);
        when(BaseProcessor.CONFIG.getString(anyString())).thenAnswer(invocation -> {
            String key = invocation.getArgument(0);
            if (key.contains("gfi.sql.query.trade.version")) return "SELECT COUNT(*) FROM trades WHERE reference_id = :referenceId";
            if (key.contains("gfi.originalSys")) return "GFI_SYSTEM";
            if (key.contains("gfi.xpath.")) return "//" + key.replace("gfi.xpath.", "");
            return "";
        });
        
        when(commonStaticData.lookupStaicData(anyString(), anyString(), anyInt())).thenReturn("");
        when(exchange.getIn().getBody(eq(String.class))).thenReturn(fixmessage);
        when(exchange.getProperty(eq("originalTrackingId"), eq(String.class))).thenReturn("test-tracking");
        
        when(xPathParser.evaluate(anyString())).thenReturn("TEST_VALUE");
        when(namedParameterJdbcTemplate.queryForObject(anyString(), any(Map.class), eq(Long.class))).thenReturn(0L);
        
        // Act
        stpProcessor.handleExchange(exchange);
        
        // Assert
        verify(exchange).setProperty(eq("_originalSys"), eq("GFI_SYSTEM"));
    }
}
