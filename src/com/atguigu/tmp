package com.scb.mxg.mls.rt.gfi.processor;

import com.scb.mxg.mls.rt.gfi.vo.TradeEvent;
import com.scb.mxg.mls.trade.TradeEventType;
import com.scb.mxg.mls.utils.XPathParser;
import com.scb.mxg.mls.vo.Journal;
import org.apache.camel.Exchange;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.time.DateFormatUtils;
import org.apache.commons.lang3.time.DateUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

public final class StpProcessor extends BaseProcessor {
    private NamedParameterJdbcTemplate namedParameterJdbcTemplate;
	private final static Logger LOG = LoggerFactory
			.getLogger(StpProcessor.class);

	@Override
	public void handleExchange(Exchange exchange) throws Exception {
        String singleLegFixML = StringUtils.trimToEmpty(exchange.getIn().getBody(
                String.class));
        XPathParser intraXmlParser = new XPathParser(singleLegFixML);
        String legType = intraXmlParser.evaluate(CONFIG.getString("gfi.xpath.LegType"));
        String legSubId=intraXmlParser.evaluate(CONFIG.getString("gfi.xpath.LegSubID"));
        String hedgeCurrency="";
//        if("HedgeLegs".equals(legType)){
        if("HedgeLegs".equals(legType) && "2".equals(legSubId)){
            hedgeCurrency=intraXmlParser.evaluate(CONFIG.getString("gfi.xpath.hedgeCurrency"));
        }

        if("2".equals(legSubId) && hedgeCurrency.isEmpty()){
            LOG.info("ignore the invalid hedge leg!");
        }else{

            /******************* step 1: prepare basic data ********************/
            String originalTrackingId = exchange.getProperty(ORIGINAL_TRACKING_ID,String.class);
            namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(mlsDbJdbcTemplate);

            String tradeExternalId = intraXmlParser.evaluate(CONFIG.getString("gfi.xpath.tradeExternalId"));
            String maxLegVal = intraXmlParser.evaluate(CONFIG.getString("gfi.xpath.MaxLegVal"));
            String legID =intraXmlParser.evaluate(CONFIG.getString("gfi.xpath.LegID"));
            String legSubID=intraXmlParser.evaluate(CONFIG.getString("gfi.xpath.LegSubID"));
            String originalId = getFullTradeId(tradeExternalId,legType,maxLegVal,legID,legSubID);

            String originalSys = CONFIG.getString("gfi.originalSys");
            String version = UUID.randomUUID().toString();

            String tradeType = intraXmlParser.evaluate(CONFIG.getString("gfi.xpath.tradeType"));
            String tradeDateStr = intraXmlParser.evaluate(CONFIG.getString("gfi.xpath.tradeDate"));
            String trader = intraXmlParser.evaluate(CONFIG.getString("gfi.xpath.trader"));
            LOG.info(
                    "process stp, original tracking Id id: {}, originalId: {}, originalSys: {}, version: {}",
                    originalTrackingId, originalId, originalSys, version);

            boolean isExisting = isExisting(originalId, originalSys);

            String tradeEvent = TradeEventType.NEW;
            // ============== save singleLegFixML in message
            Journal inJournal = new Journal();
            inJournal.setContent(singleLegFixML);
            inJournal.setStatus(Journal.RECEIVED);
            inJournal.setReferId(originalId);
            inJournal.setType(tradeEvent);
            inJournal.setTrackingId(originalTrackingId);
            saveJournal(exchange, inJournal);

            exchange.setProperty("_originalId", originalId);
            exchange.setProperty("_originalSys", originalSys);
            exchange.setProperty("_version", version);
            exchange.setProperty("_inJournalId", inJournal.getId());
            exchange.setProperty("_trader",trader);
            exchange.setProperty("_trade_id",originalId);
            exchange.setProperty("_tradeEvent",tradeEvent);
            exchange.setProperty("_intraXml",singleLegFixML);

            // check the duplication of trade
            if (isExisting) {
                // =============== record event
                TradeEvent event = new TradeEvent();
                event.setOriginalId(originalId);
                event.setOriginalSys(originalSys);
                event.setVersion(version);
                event.setTrackingId(inJournal.getId());
                event.setEventSource(originalSys);
                event.setAction(tradeEvent);
                event.setSubAction(TradeEventType.DUPLICATE);
                event.setDetails("");
                event.setComments("");
                event.setReferSysStatus("");
                event.setReferSysTradeId("");
                event.setTradeDate(DateFormatUtils.ISO_DATE_FORMAT.format(DateUtils
                        .parseDate(tradeDateStr, "yyyyMMdd")));
                event.setTradeType(tradeType);
                recordTradeEvent(exchange, event);
            } else {
                // =============== record event
                TradeEvent event = new TradeEvent();
                event.setOriginalId(originalId);
                event.setOriginalSys(originalSys);
                event.setVersion(version);
                event.setTrackingId(inJournal.getId());
                event.setEventSource(originalSys);
                event.setAction(tradeEvent);
                event.setSubAction("");
                event.setDetails("");
                event.setComments("");
                event.setReferSysStatus("");
                event.setReferSysTradeId("");
                event.setTradeDate(DateFormatUtils.ISO_DATE_FORMAT.format(DateUtils
                        .parseDate(tradeDateStr, "yyyyMMdd")));
                event.setTradeType(tradeType);
                recordTradeEvent(exchange, event);

                // transform to murex
                transformToMurex(exchange, singleLegFixML, tradeEvent, originalTrackingId,
                        originalId, originalSys, version, inJournal.getId());
            }
        }

	}

    private final static String trade_version = CONFIG.getString("gfi.sql.query.trade.version");

    boolean isExisting(String originalId, String originalSys) {
        boolean res = false;
//        NamedParameterJdbcTemplate namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(mlsDbJdbcTemplate);
        Map<String, String> map = new HashMap<>();
        map.put("referenceId",originalId);
        map.put("originalId",originalId);
        Long count = namedParameterJdbcTemplate.queryForObject(trade_version, map, Long.class);
        if (count > 0) {
            res = true;
        }
        return res;
    }
}


上面类怎么完善如下的测试类?目前namedParameterJdbcTemplate无法mock，请帮助mock namedParameterJdbcTemplate并覆盖尽可能多的code


package com.scb.mxg.mls.rt.gfi.processor;

import com.scb.mxg.mls.rt.data.CommonStaticData;
import com.scb.mxg.mls.rt.utils.BeanUtils;
import net.sf.saxon.s9api.XsltTransformer;
import org.apache.camel.Exchange;
import org.apache.commons.io.IOUtils;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Answers;
import org.mockito.Mock;
import org.powermock.api.mockito.PowerMockito;
import org.powermock.core.classloader.annotations.PowerMockIgnore;
import org.powermock.core.classloader.annotations.PrepareForTest;
import org.powermock.modules.junit4.PowerMockRunner;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.support.TransactionTemplate;
import org.springframework.ui.Model;

import static org.junit.Assert.assertFalse;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

@RunWith(PowerMockRunner.class)
@PrepareForTest({BeanUtils.class, CommonStaticData.class, Model.class})
@PowerMockIgnore({"javax.management.*", "javax.script.*"})
public class StpProcessorTest {

    private StpProcessor stpProcessor;
    private TransactionTemplate mlsDbTransactionTemplate;
    private String fixmessage;
    private String fixmessage2;
    private String fixmessage3;
    private String fixmessage4;
    private String errorFixMessage;
    @Mock
    private CommonStaticData commonStaticData;
    @Mock
    private JdbcTemplate mlsDbJdbcTemplate;
    @Mock
    private PlatformTransactionManager transactionManager;
    @Mock
    private XsltTransformer xsltTransformer;
    @Mock(answer = Answers.RETURNS_DEEP_STUBS)
    private Exchange exchange;
    @Mock(answer = Answers.RETURNS_DEEP_STUBS)
    private Exchange errorExchange;
    @Before
    public void setUp() throws Exception {
        fixmessage = IOUtils.toString(getClass().getResourceAsStream("/inputFiles/normalFixml.xml"), "UTF-8");
        fixmessage2 = IOUtils.toString(getClass().getResourceAsStream("/inputFiles/normalFixml2.xml"), "UTF-8");
        fixmessage3 = IOUtils.toString(getClass().getResourceAsStream("/inputFiles/normalFixml3.xml"), "UTF-8");
        fixmessage4 = IOUtils.toString(getClass().getResourceAsStream("/inputFiles/normalFixml4.xml"), "UTF-8");
        errorFixMessage = IOUtils.toString(getClass().getResourceAsStream("/inputFiles/errorFix.xml"), "UTF-8");
        stpProcessor = new StpProcessor();
        stpProcessor.setMlsDbJdbcTemplate(mlsDbJdbcTemplate);
        mlsDbTransactionTemplate = new TransactionTemplate(transactionManager);
        stpProcessor.setMlsDbTransactionTemplate(mlsDbTransactionTemplate);
        PowerMockito.mockStatic(BeanUtils.class);
        PowerMockito.when(BeanUtils.getBean("commonStaticData")).thenReturn(commonStaticData);
        PowerMockito.mockStatic(Model.class);
        //PowerMockito.when(Model.lookup(anyString())).thenReturn("");
    }

    @Test
    public void handleExchange() throws Exception {
        when(commonStaticData.lookupStaicData(anyString(), anyString(), anyInt())).thenReturn("");
        when(exchange.getIn().getBody(eq(String.class))).thenReturn(fixmessage);
        when(exchange.getIn().getBody()).thenReturn("");

        when(errorExchange.getIn().getBody(eq(String.class))).thenReturn(errorFixMessage);
        when(errorExchange.getIn().getBody()).thenReturn("");
        when(mlsDbJdbcTemplate.queryForObject(anyString(), any(Object[].class),eq(Long.class))).thenReturn(0L);
        try {
            stpProcessor.handleExchange(exchange);
            when(exchange.getIn().getBody(eq(String.class))).thenReturn(fixmessage2);
            when(exchange.getIn().getBody()).thenReturn("");
            stpProcessor.handleExchange(exchange);
            when(exchange.getIn().getBody(eq(String.class))).thenReturn(fixmessage3);
            when(exchange.getIn().getBody()).thenReturn("");
            stpProcessor.handleExchange(exchange);
            when(exchange.getIn().getBody(eq(String.class))).thenReturn(fixmessage4);
            when(exchange.getIn().getBody()).thenReturn("");
            stpProcessor.handleExchange(exchange);
        } catch (Exception e) {

        }
    }
}
